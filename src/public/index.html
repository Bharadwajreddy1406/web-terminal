<!DOCTYPE html>
<html>
  <head>
    <title>Web Terminal</title>
    <style>
      body { 
        background: #000; 
        color: #0f0; 
        font-family: monospace; 
        padding: 10px; 
        margin: 0;
      }
      
      .header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding: 5px 0;
        border-bottom: 1px solid #333;
      }
      
      .title {
        font-size: 18px;
        font-weight: bold;
      }
      
      .buttons {
        display: flex;
        gap: 10px;
      }
      
      .btn {
        background: #333;
        color: #0f0;
        border: 1px solid #0f0;
        padding: 5px 15px;
        cursor: pointer;
        font-family: monospace;
        font-size: 12px;
        border-radius: 3px;
        transition: background-color 0.2s;
      }
      
      .btn:hover {
        background: #0f0;
        color: #000;
      }
      
      .shell-selector {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-right: 20px;
      }
      
      .shell-dropdown {
        background: #111;
        color: #0f0;
        border: 1px solid #333;
        padding: 5px 10px;
        font-family: monospace;
        font-size: 12px;
        border-radius: 3px;
        cursor: pointer;
      }
      
      .shell-dropdown:focus {
        outline: none;
        border-color: #0f0;
      }
      
      .current-shell {
        font-size: 12px;
        color: #888;
        font-style: italic;
      }
      
      #output { 
        white-space: pre-wrap; 
        min-height: 400px;
        max-height: 70vh;
        overflow-y: auto;
        padding: 5px;
        border: 1px solid #333;
        margin-bottom: 10px;
      }
      
      .system-message {
        color: #ff6600 !important;
        font-weight: bold;
        background-color: rgba(255, 102, 0, 0.1);
        padding: 2px 4px;
        border-left: 3px solid #ff6600;
        margin: 5px 0;
        display: block;
      }
      
      .input-container {
        display: flex;
        align-items: center;
      }
      
      .prompt {
        color: #0f0;
        margin-right: 5px;
      }
      
      input { 
        flex: 1;
        background: #111; 
        color: #0f0; 
        border: none; 
        outline: none; 
        font-family: monospace;
        padding: 5px;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <div class="title">Web Terminal</div>
      <div style="display: flex; align-items: center;">
        <div class="shell-selector">
          <label for="shellSelect" style="color: #0f0; font-size: 12px;">Shell:</label>
          <select id="shellSelect" class="shell-dropdown">
            <option value="">Loading...</option>
          </select>
        </div>
        <div class="current-shell" id="currentShell">Current: Default</div>
        <div class="buttons">
          <button class="btn" onclick="newSession()">New</button>
          <button class="btn" onclick="clearTerminal()">Clear</button>
        </div>
      </div>
    </div>
    
    <div id="output"></div>
    
    <div class="input-container">
      <span class="prompt">$</span>
      <input id="input" autofocus />
    </div>
    <script>
      const ws = new WebSocket(`ws://${location.host}`);
  const output = document.getElementById("output");
  const input = document.getElementById("input");
  const inputContainer = document.querySelector('.input-container');
      const shellSelect = document.getElementById("shellSelect");
      const currentShellDisplay = document.getElementById("currentShell");
      
      let availableShells = [];
      let currentShell = "Default";
      
      // Load available shells on page load
      async function loadShells() {
        try {
          const response = await fetch('/api/shells');
          const shellData = await response.json();
          availableShells = shellData.shells;
          
          // Clear existing options
          shellSelect.innerHTML = '';
          
          // Add shells to dropdown
          shellData.shells.forEach(shell => {
            const option = document.createElement('option');
            option.value = shell;
            option.textContent = shell;
            shellSelect.appendChild(option);
          });
          
          // Set default selection
          if (shellData.shells.length > 0) {
            const defaultShell = shellData.OS === 'windows' ? 'cmd.exe' : 'bash';
            const defaultIndex = shellData.shells.indexOf(defaultShell);
            if (defaultIndex !== -1) {
              shellSelect.selectedIndex = defaultIndex;
              currentShell = defaultShell;
              updateCurrentShellDisplay();
            }
          }
        } catch (error) {
          console.error('Failed to load shells:', error);
          shellSelect.innerHTML = '<option value="">Error loading shells</option>';
        }
      }
      
      // Handle shell selection change
      shellSelect.addEventListener('change', function() {
        const selectedShell = this.value;
        if (selectedShell && selectedShell !== currentShell) {
          ws.send(`__SELECT_SHELL__:${selectedShell}`);
        }
      });
      
      // Update current shell display
      function updateCurrentShellDisplay() {
        currentShellDisplay.textContent = `Current: ${currentShell}`;
      }
      
      // localStorage key for session persistence
      const STORAGE_KEY = 'web_terminal_session';
      const MAX_STORAGE_SIZE = 100000; // Max characters to store (configurable)
      
      // Function to save output to localStorage
      function saveToStorage(data) {
        try {
          let stored = localStorage.getItem(STORAGE_KEY) || '';
          stored += data;
          
          // if exceeds max size
          if (stored.length > MAX_STORAGE_SIZE) {
            stored = stored.slice(-MAX_STORAGE_SIZE);
          }
          
          localStorage.setItem(STORAGE_KEY, stored);
        } catch (e) {
          // Storage quota exceeded or not available
          console.warn('localStorage not available:', e);
        }
      }
      
      // Function to restore output from localStorage
      function restoreFromStorage() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
            output.textContent = stored;
            // scroll the output element to the bottom
            output.scrollTop = output.scrollHeight;
          }
        } catch (e) {
          console.warn('Failed to restore from localStorage:', e);
        }
      }
      
      // Function to clear terminal output
      function clearOutput() {
        output.textContent = '';
        localStorage.removeItem(STORAGE_KEY);
        // reset the output scroll to top
        output.scrollTop = 0;
      }
      
      // Button functions
      function newSession() {
        ws.send("__NEW_SESSION__");
        clearOutput();
      }
      
      function clearTerminal() {
        ws.send("__CLEAR__");
      }
      
      // Restore previous session on page load
      restoreFromStorage();
      
      // Load available shells
      loadShells();
      
      // console.log(`ws://${location.host}`);
      
      ws.onmessage = (e) => { 
        const data = e.data;
        
        // Handle special clear command from server
        if (data === "__CLEAR_OUTPUT__") {
          clearOutput();
          return;
        }
        
        // Handle shell change notification
        if (data.startsWith("__SHELL_CHANGED__:")) {
          const newShell = data.replace("__SHELL_CHANGED__:", "");
          currentShell = newShell;
          updateCurrentShellDisplay();
          
          // Update dropdown selection to match
          const shellIndex = availableShells.indexOf(newShell);
          if (shellIndex !== -1) {
            shellSelect.selectedIndex = shellIndex;
          }
          return;
        }
        
        // Check if this is a system message and style it differently
        if (data.includes('[SYSTEM]')) {
          const lines = data.split('\n');
          let processedData = '';
          
          lines.forEach(line => {
            if (line.includes('[SYSTEM]')) {
              // Create a styled system message
              const messageContent = line.replace('[SYSTEM]', '').trim();
              processedData += `\n● SYSTEM: ${messageContent}\n`;
            } else if (line.trim()) {
              processedData += line + '\n';
            } else {
              processedData += '\n';
            }
          });
          
          output.textContent += processedData;
        } else {
          output.textContent += data;
        }
        
        saveToStorage(data);
        // ensure the output container scrolls to the bottom when new data arrives
        output.scrollTop = output.scrollHeight;
      };
      
      input.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          const command = input.value;
          
          // Handle special commands locally for immediate feedback
          if (command === "clear" || command === "cls") {
            clearOutput();
            input.value = "";
            return;
          }
          
          ws.send(command);
          const userInput = "> " + command + "\n";
          output.textContent += userInput;
          saveToStorage(userInput);
          input.value = "";
          // scroll the output container to the bottom after adding user's command
          output.scrollTop = output.scrollHeight;
        }
      });
      
      // Optional: Clear session storage on demand
      window.clearTerminalSession = function() {
        clearOutput();
        console.log('Terminal session cleared');
      };
      
      // Clicking anywhere inside the input container should focus the input
      if (inputContainer) {
        inputContainer.addEventListener('click', function(e) {
          // If the native input itself was clicked, let the browser handle caret placement
          if (e.target === input) return;

          // Compute approximate caret position based on click X coordinate
          const rect = input.getBoundingClientRect();
          const clickX = e.clientX - rect.left;

          // measure an approximate character width using a hidden span
          const style = window.getComputedStyle(input);
          const measurer = document.createElement('span');
          measurer.style.visibility = 'hidden';
          measurer.style.position = 'absolute';
          measurer.style.whiteSpace = 'pre';
          measurer.style.font = style.font;
          measurer.textContent = 'M';
          document.body.appendChild(measurer);
          const charWidth = measurer.getBoundingClientRect().width || 8;
          document.body.removeChild(measurer);

          let index = Math.floor(clickX / charWidth);
          index = Math.max(0, Math.min(index, input.value.length));
          input.setSelectionRange(index, index);
          input.focus();
        });
      }

      // Focus input when clicking anywhere in the terminal area (non-interactive regions)
      document.addEventListener('click', function(e) {
        // Ignore clicks on interactive elements (buttons, dropdowns, and the input itself)
        if (!e.target.closest('.btn') && !e.target.closest('.shell-dropdown') && !e.target.closest('#input')) {
          // If the click wasn't inside the input container, place caret at the end
          if (!e.target.closest('.input-container')) {
            input.focus();
            const len = input.value.length;
            input.setSelectionRange(len, len);
          }
        }
      });
    </script>
  </body>
</html>
